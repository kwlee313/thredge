# 목록_페이징_및_검색_최적화_계획

## 배경/문제
- 스레드/검색/숨김 목록 API가 전체 데이터를 한 번에 반환하고 있다.
- feed/search에서 thread별 entries 조회가 반복되어 N+1 패턴이 발생한다.
- 현재 구조는 명확하지만 문서화가 부족해 신규 참여자 온보딩이 어렵다.

## 목표
- 목록 API에 페이징/리미트를 도입해 성능과 안정성을 개선한다.
- feed/search의 데이터 조회를 최적화해 DB 부하를 줄인다.
- DTO/Service 레이어 구조를 간단한 문서로 정리한다.

## 범위
- 포함
  - Thread/Entry 관련 목록 API 페이징 적용
  - search/feed/hidden 조회 최적화
  - backend 구조 문서화(간단한 ADR 또는 README)
- 제외
  - API 스펙 대규모 변경(필요 최소한의 파라미터 추가만)
  - 프론트 변경(필요 시 별도 작업으로 분리)

## 현재 동작 정리
- `feed/search`는 thread 목록을 조회한 뒤 entries를 개별 조회한다.
- `search`는 빈 query를 400 처리한다.
- 페이징 파라미터가 없어 목록이 커질수록 응답이 비대해질 수 있다.

## 개선 방향
- `Pageable` 또는 `limit/offset` 방식 중 하나를 선택해 일관 적용한다.
- feed/search는 batch 조회 또는 join fetch 방식으로 N+1을 최소화한다.
- 문서는 “구조/의도/확장 포인트” 중심의 간단한 가이드로 작성한다.

## 단계별 계획
- 1단계: 페이징 정책 결정
  - 기본 size/최대 size 정의
  - 목록 API에 적용할 범위 확정
  - 완료 기준: 페이징 파라미터와 기본값 문서화
- 2단계: 조회 최적화
  - feed/search에서 entries 조회 방식 개선
  - 필요 시 repository 메서드 추가
  - 완료 기준: 주요 목록에서 N+1 제거
- 3단계: API 응답 정리
  - 페이징 응답 포맷 확정(총 개수/다음 페이지 등)
  - 완료 기준: 응답 포맷 문서화
- 4단계: 문서화
  - DTO/Service 레이어 구조 요약 문서 추가
  - 완료 기준: 신규 온보딩 기준 설명 완료

## 리스크 및 대응
- 페이징 도입으로 기존 클라이언트 동작 변경 위험
  - 대응: 기본값 제공 및 하위 호환 유지
- 조회 최적화로 데이터 정렬/필터 순서가 달라질 위험
  - 대응: 기존 정렬 기준 유지 테스트

## 검증 계획
- 목록 API에서 페이징 파라미터 정상 동작 확인
- feed/search에서 응답 데이터 정합성 비교
- 성능 확인(쿼리 수 감소 확인)
