# 스레드 테이블/스키마/권한 분석 결과

## 개요
- 분석 대상: 백엔드 JPA 엔티티/리포지토리/서비스/컨트롤러, Spring Session JDBC
- 목적: 테이블 수 적절성, 스키마 설계 적절성, 사용자 간 접근 통제 확인

## 테이블 수 적절성 판단
- 도메인 핵심 테이블: `users`, `threads`, `entries`, `categories`, `thread_categories`로 구성되어 있으며 책임 분리가 명확함.
- 세션 저장을 위한 `SPRING_SESSION`, `SPRING_SESSION_ATTRIBUTES`가 추가됨.
- 현재 기능 범위(사용자, 스레드, 엔트리, 카테고리, 세션)에 비추어 테이블 수는 과도하지 않으며 정상 범위.

## 테이블 스키마 상세

### 1) users
- 출처: `backend/src/main/kotlin/com/thredge/backend/domain/entity/UserEntity.kt`
- 컬럼
  - `id` uuid, PK, NOT NULL (JPA UUID 생성)
  - `username` varchar(80), NOT NULL, UNIQUE
  - `password_hash` varchar(200), NOT NULL
  - `created_at` timestamp, NOT NULL
  - `updated_at` timestamp, NOT NULL
- 제약/인덱스
  - UNIQUE(`username`)
  - 기타 명시적 인덱스 없음
- 비고
  - username이 스레드/카테고리의 소유자 식별자로 사용됨 (FK 미사용)

### 2) threads
- 출처: `backend/src/main/kotlin/com/thredge/backend/domain/entity/ThreadEntity.kt`
- 컬럼
  - `id` uuid, PK, NOT NULL
  - `title` varchar(200), NOT NULL
  - `body` text, NULL
  - `owner_username` varchar(80), NOT NULL
  - `is_hidden` boolean, NOT NULL
  - `is_pinned` boolean, NOT NULL
  - `created_at` timestamp, NOT NULL
  - `updated_at` timestamp, NOT NULL
  - `last_activity_at` timestamp, NOT NULL
- 제약/인덱스
  - 명시적 FK/인덱스 없음
- 관계
  - 다대다: `categories`와 연결 (조인 테이블 `thread_categories`)

### 3) entries
- 출처: `backend/src/main/kotlin/com/thredge/backend/domain/entity/EntryEntity.kt`
- 컬럼
  - `id` uuid, PK, NOT NULL
  - `thread_id` uuid, NOT NULL (threads 참조)
  - `parent_entry_id` uuid, NULL (자기 참조용)
  - `body` text, NOT NULL
  - `is_hidden` boolean, NOT NULL
  - `created_at` timestamp, NOT NULL
  - `updated_at` timestamp, NOT NULL
- 제약/인덱스
  - 명시적 FK/인덱스 없음
- 관계
  - 다대일: `threads`
  - `parent_entry_id`는 애플리케이션에서 깊이/일치 검증 (DB FK 없음)

### 4) categories
- 출처: `backend/src/main/kotlin/com/thredge/backend/domain/entity/CategoryEntity.kt`
- 컬럼
  - `id` uuid, PK, NOT NULL
  - `name` varchar(80), NOT NULL
  - `owner_username` varchar(80), NOT NULL
  - `thread_count` bigint, NOT NULL
- 제약/인덱스
  - UNIQUE(`owner_username`, `name`)
  - 기타 명시적 인덱스 없음

### 5) thread_categories (조인 테이블)
- 출처: `ThreadEntity`의 `@ManyToMany` + `@JoinTable(name = "thread_categories")`
- 컬럼(추정)
  - `thread_id` uuid, NOT NULL
  - `categories_id` uuid, NOT NULL
- 제약/인덱스
  - 명시적 제약 없음 (조인 컬럼/유니크 제약 미정)
- 비고
  - `@JoinTable`에 `joinColumns`, `inverseJoinColumns`가 명시되지 않아 실제 컬럼명/제약은 Hibernate 기본 네이밍 전략에 의존.
  - 조인 테이블 레벨에서 소유자 일치 제약이 없음.

### 6) SPRING_SESSION (세션 저장)
- 출처: Spring Session JDBC 기본 스키마 (store-type: jdbc)
- 컬럼(기본 스키마 기준)
  - `PRIMARY_ID` char(36), PK
  - `SESSION_ID` char(36), UNIQUE
  - `CREATION_TIME` bigint, NOT NULL
  - `LAST_ACCESS_TIME` bigint, NOT NULL
  - `MAX_INACTIVE_INTERVAL` int, NOT NULL
  - `EXPIRY_TIME` bigint, NOT NULL
  - `PRINCIPAL_NAME` varchar(100), NULL
- 제약/인덱스
  - PK(`PRIMARY_ID`), UNIQUE(`SESSION_ID`)
  - `PRINCIPAL_NAME` 인덱스는 스키마 옵션에 따라 존재할 수 있음

### 7) SPRING_SESSION_ATTRIBUTES (세션 속성)
- 출처: Spring Session JDBC 기본 스키마 (store-type: jdbc)
- 컬럼(기본 스키마 기준)
  - `SESSION_PRIMARY_ID` char(36), NOT NULL (SPRING_SESSION 참조)
  - `ATTRIBUTE_NAME` varchar(200), NOT NULL
  - `ATTRIBUTE_BYTES` bytea, NOT NULL
- 제약/인덱스
  - PK(`SESSION_PRIMARY_ID`, `ATTRIBUTE_NAME`)
  - FK(`SESSION_PRIMARY_ID`) -> `SPRING_SESSION(PRIMARY_ID)`

## 스키마 적절성 평가
- 긍정적
  - 주요 도메인(사용자, 스레드, 엔트리, 카테고리) 분리가 명확.
  - 카테고리 유니크 제약과 사용자 유니크 제약으로 중복 방지.
  - 스레드/엔트리의 숨김 플래그로 소프트 삭제 전략 일관.
- 개선/리스크
  - `threads.owner_username`/`categories.owner_username`가 `users.id`에 대한 FK가 아님.
    - 사용자 이름 변경/삭제 시 참조 무결성 보장 불가.
  - `entries.parent_entry_id`에 FK 및 제약이 없어 데이터 무결성이 앱 로직에 의존.
  - `thread_categories` 조인 테이블에 소유자 일치 제약이 없어 데이터 정합성은 앱 로직에 의존.
  - 명시적 인덱스 부족: 조회 패턴(예: owner_username, created_at, last_activity_at)에 비해 인덱스가 없다.

## 사용자 간 접근 통제 분석

### 인증
- 전 API는 `/api/auth/login`, `/api/auth/signup`, 헬스 체크를 제외하고 인증 필요.
- `AuthSupport.requireUsername`으로 인증 실패 시 즉시 차단.

### 스레드 접근
- `ThreadService.findThread`는 `findByIdAndOwnerUsername`만 사용.
- 숨김 스레드는 `includeHidden`이 false면 NotFound 처리.
- 공격 시나리오(타인 스레드 ID로 조회/수정/삭제):
  - 모든 호출 경로에서 `ownerUsername`을 필터로 사용하므로 타인 데이터 접근 불가.

### 엔트리 접근
- `EntryService.findEntry`는 `findByIdAndThreadOwnerUsername` 사용.
- 공격 시나리오(타인 엔트리 ID로 수정/삭제/복구):
  - 스레드 소유자 기준으로 차단되어 접근 불가.

### 카테고리 접근
- 수정/삭제 시 `category.ownerUsername` 비교 후 불일치면 NotFound.
- 스레드-카테고리 연결은 `resolveCategories(ownerUsername)`로 소유자 범위에 제한.

## 결론
- 현재 API 계층에서 사용자 간 데이터 분리는 일관되게 적용되고 있어, 다른 사용자의 스레드/엔트리 접근 공격은 정상적으로 차단된다.
- 스키마는 기능 범위에 비해 적절한 수의 테이블을 사용하고 있으나, FK/인덱스 부족으로 무결성 및 성능 리스크가 존재한다.

## 권장 개선 사항(우선순위)
- 1) `users.id` 기반 FK로 소유자 참조를 전환하거나, `owner_username` 변경을 제한/감지하는 정책 도입.
- 2) `thread_categories`에 명시적 `joinColumns`/`inverseJoinColumns` 및 UNIQUE 제약 추가.
- 3) `entries.parent_entry_id` FK 및 ON DELETE 정책 정의.
- 4) 자주 조회되는 컬럼(`owner_username`, `last_activity_at`, `created_at`) 인덱스 추가.
